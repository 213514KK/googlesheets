---
title: "Understanding the feeds"
output:
  html_document:
    keep_md: true
    toc: true
---

```{r}
library("plyr")
suppressPackageStartupMessages(library("dplyr"))
library("rlist")
library("stringr")
## I want to use unexported functions here
devtools::load_all(pkg = "~/research/googlesheets/")
#library("googlesheets")
```

```{r authorize, include = FALSE}
if(!file.exists(".httr-oauth")) {
  ## look for .httr-oauth in pwd (assuming pwd is googlesheets) or one level up
  ## (assuming pwd is googlesheets/data-for-demo
  pwd <- getwd()
  one_up <- pwd %>% dirname()
  HTTR_OAUTH <- c(one_up, pwd) %>% file.path(".httr-oauth")
  HTTR_OAUTH <- HTTR_OAUTH[HTTR_OAUTH %>% file.exists()]
  
  if(length(HTTR_OAUTH) > 0) {
    HTTR_OAUTH <- HTTR_OAUTH[1]
    file.copy(from = HTTR_OAUTH, to = ".httr-oauth", overwrite = TRUE)
  }
}
```

There's some stuff I want to do that requires better documentation of what we can get our hands on via the different feeds. This needs to be written down, in detail, in one place. Here we go.

Thinking out loud prior to refactoring the `list_sheets()` + `identify_ss()` + `register_ss()` trio of functions. What's on my mind:

  * It is annoying that `identify_ss()` is so rigid about identifying exactly one Sheet. I need to relax that.
  * Currently `identify_ss()` returns a sparsely populated `googlesheets` object and I'm not fond of the idea of returning ... a list of multiple such objects? So simply allowing `identify_ss()` to return info on multiple Sheets does not sound like a good idea.
  * `list_sheets()` returns a `tbl` already and thus seems to more naturally fit the "multiple sheets" mandate. Maybe it should get some arguments to give the user control over which sheets will be listed, as opposed to always listing all of them.
  * Old sheets present a vexing problem where the alternate key needed downstream for `delete_ss()`, `copy_ss()`, and `download_ss()` is not available from the sheet's worksheets feed but can be dug out of the spreadsheets feed.
  * `identify_ss()` creates a `googlesheets` object but gets its info from the spreadsheets feed. `register_ss()` creates a `googlesheets` object but gets its info from the worksheets feed. I'd prefer these things be better aligned.

## Spreadsheets feed

The interesting info that comes back from the spreadsheet feed consists of the `entry` nodes, one per sheet. These nodes appear to have the same structure for each sheet and we'll get an overview for the first sheet as well.

```{r}
the_url <- "https://spreadsheets.google.com/feeds/spreadsheets/private/full"
req <- gsheets_GET(the_url)
sheet_list <- req %>%
  list.extract("content") %>%
  list.match("entry")
sheet_list %>% str1
sheet_list[[1]] %>% str
```

What is all this stuff?

  * `id` and `updated` ... check.
  * `category` seems utterly useless to me.
  * `title/text` and `content/text` ... we check below if they are always the same.
  * The 3 links are worth keeping. We'll come back to them.
  * `author/name` and `author/email` are worth keeping.
  
Let's compare `title/text` and `content/text`.

```{r}
title_stuff <-
#   data_frame(title = laply(sheet_list, function(x) x$title$text),
#              content = laply(sheet_list, function(x) x$content$text))
  data_frame(title = sheet_list %>% list.map(title) %>% list.mapv(text),
             content = sheet_list %>% list.map(content) %>% list.mapv(text))
title_stuff
with(title_stuff, identical(title, content))
```

For this set of sheets, at least, YES this info is redundant. Set the names for  `sheet_list` to the sheet titles.

```{r}
names(sheet_list) <- title_stuff$title
```

### Links returned by the spreadsheets feed

Each `entry` node has an `id` element containing a link plus 3 additional nodes named `link`. I gather all 4 into a `tbl` for further inspection.

```{r}
jfun <- function(x) { # lots o' gymnastics required here
  links <- x %>%
    list.match("^link$") %>%
    unname %>% 
    list.rbind %>%
    as.data.frame
  links$source <- "content/entry/link"
  links <- links %>%
    rbind(data.frame(rel = NA, type = NA, href = x$id,
                     source = "content/entry/id"))
  links %>%
    mutate(sheet_title = x[["title"]][["text"]],
           feed = "ss") %>%
    select(feed, sheet_title, source, href, rel, type)
}
ss_links <- sheet_list %>%
  list.map(jfun(.))
links <- ss_links %>%
  bind_rows
links
```

From previous inspections, I know the "self" and `id` links look the same. Is that generally true?

```{r}
links %>%
  filter(rel == "self" | source == "content/entry/id") %>%
  group_by(sheet_title) %>%
  summarize(query = n_distinct(href) == 1) %>%
  list.extract("query") %>%
  all
```

Yes they are exactly the same. Duly noted. Let's see the overall structure of the links, starting with the "self" or `id` link.

```{r}
links %>%
  filter(rel == "self") %>%
  list.extract("href") %>%
  str_split_fixed("//*", n = 7)
```

Do same for the worksheets feed, which I happen to know is the link with `"rel"` equal to `http://schemas.google.com/spreadsheets/2006#worksheetsfeed`.

```{r}
links %>%
  filter(str_detect(rel, "2006#worksheetsfeed")) %>%
  list.extract("href") %>%
  str_split_fixed("//*", n = 7)
```

Do same for the "alternate" link:

```{r}
links %>%
  filter(rel == "alternate") %>%
  list.extract("href") %>%
  str_split_fixed("//*", n = 6)
```

We've got more variety here, due to old sheets vs new. Note that, in addition to the obvious difference in domain and overall URL structure, the old sheets present an alternative key in the "alternate" link.

### Structure and content of spreadsheets feed links

```sh
id = "self" link:
https://spreadsheets.google.com/feeds/spreadsheets/VISIBILITY/PROJECTION/KEY
VISIBILITY = {private (default), public}
PROJECTION = {full (default), basic}

worksheets feed:
https://spreadsheets.google.com/feeds/worksheets/KEY/VISIBILITY/PERMISSION
VISIBILITY = {private (default), public}
PERMISSION = {full (read and write), values (read only)}

"alternate" link, new sheets:
https://docs.google.com/spreadsheets/d/KEY/edit

"alternate" link, old sheets:
https://spreadsheets.google.com/ccc?key=ALT_KEY
```

### Old sheets vs new, sheet permissions

Create new variables to hold info about whether a sheet is old or new and whether current user is allowed to read only or to read and write.

```{r}
version_df <- links %>%
  filter(rel == "alternate") %>%
  transmute(sheet_title,
            version = ifelse(grepl("^https://docs.google.com/spreadsheets/d",
                                   href), "new", "old"))
perm_df <- links %>%
  filter(str_detect(rel, "2006#worksheetsfeed")) %>%
  transmute(sheet_title,
            perm = ifelse(grepl("values", href), "r", "rw"))
links <- links %>%
  left_join(version_df) %>%
  left_join(perm_df)
```

### Keys in the links

Extract the key from each link.

```{r}
links <- links %>%
  mutate(link_key = extract_key_from_url(href))
```

Hypothesis: all link keys are uniform for a new sheet.

```{r}
links %>%
  filter(version == "new") %>%
  group_by(sheet_title) %>%
  summarize(query = n_distinct(link_key) == 1) %>%
  list.extract("query") %>%
  all
```

Hypothesis: The "self" and worksheets feed keys agree for an old sheet but differ from the "alternate" key.

```{r}
links %>%
  filter(rel %>% str_detect("2006#worksheetsfeed|self|alternate")) %>%
  group_by(sheet_title) %>%
  summarize(query = n_distinct(link_key), version = first(version)) %>%
  group_by(version) %>%
  summarize(min = min(query), max = max(query))
```

This alternative key -- only defined for old sheets and only available through the "alternative" link found in the spreadsheets feed -- is ultimately useful to us for any operations that require the Drive API. Empirically, I note it can also be extracted from the URL seen in the browser when visiting such a sheet.

Formalize this notion of the (default) key versus the alternative key, which is only defined for old sheets and is damned hard to get.

```{r}
alt_keys <- links %>%
  filter(rel == "alternate") %>%
  group_by(sheet_title) %>%
  transmute(alt_key = ifelse(version == "new", NA_character_, link_key))
sheet_keys <- links %>%
  filter(rel == "self") %>%
  group_by(sheet_title) %>%
  transmute(sheet_key = link_key)
links <- links %>%
  left_join(alt_keys) %>%
  left_join(sheet_keys)
```

### Parting look at links and keys from spreadsheets feed

```{r}
links %>%
  glimpse
```

## Worksheets feed

Now we turn to the worksheets feed. Hand-picked 4 example sheets: all possible combinations of new vs old sheets and sheets for which I do and do not have write permission.

```{r}
my_sheets <- list_sheets()
example_sheets <- c("unitables2010final copy", "Old School Google Sheet",
                    "WI15 ARCHY 499", "Gapminder")
examples <- my_sheets %>%
  filter(sheet_title %in% example_sheets) %>%
  arrange(version, perm)
examples %>%
  select(sheet_title, version, perm)
```

Get the worksheets feed for each example sheet. Use sheet names to name the resulting list. Get overview of all the feeds and the first one as an example.

```{r}
req_list <- examples$ws_feed %>%
  list.map(gsheets_GET(.))
#names(req_list) <- substr(examples$sheet_title, 1, 12)
names(req_list) <- examples$sheet_title
req_list %>% str1
req_list[[1]] %>% str1
```

A worksheet feed request return 9 components:

  * `url` is just the worksheets feed URL itself (will be checked explicitly later once all the links are extracted)
  * `status_code`, `date`, `times` are fairly self-explanatory
  * `headers` + `all_headers`, `cookies`, `request` call for some inspection (below)
  * `content` is, of course, where it's really at (next subsection)

```{r}
req_list %>% list.mapv(cookies)
req_list %>% list.map(headers)
req_list %>% list.map(all_headers)
req_list %>% list.map(request)
```

I don't really have anything insightful to say about the above. Err, duly noted?

### Content from the worksheets feed

It is convenient to create a named list holding just the content.

```{r}
content <- req_list %>%
  list.map(content)
content %>% str1
```

Interesting! There is variability in the number of list elements. What varies?

```{r}
all_content_names <- content %>%
  list.cases(names(.))
sapply(content, function(x) table(factor(names(x), levels = all_content_names)))
```

The variation is in the multiplicity of `link` and `entry` elements.  We'll come back to this, but let's inspect the more boring components before we move on. Most contain familiar info from the spreadsheets feed.

```{r}
## author name and email
## this not good because sheet_titleis lost :(
#content %>% list.map(author) %>% list.stack
wsf <-
  content %>%
  list.map(author) %>%
  ldply(as.data.frame, .id = "sheet_title")
ssf <- sheet_list %>%
  list.match(paste0("^", example_sheets, "$", collapse = "|")) %>%
  list.map(author) %>%
  ldply(as.data.frame, .id = "sheet_title")
full_join(ssf, wsf, by = "sheet_title") %>%
  mutate_each(funs("as.character")) %>%
  mutate(name_agree = name.x == name.y,
         email_agree = email.x == email.y)

## title
(tmp <- content %>% list.map(title) %>% list.mapv(text))
all.equal(tmp, names(content), check.names = FALSE)

## time of last update
data_frame(ws_updated = content %>% list.mapv(updated) %>%
            as.POSIXct(format = "%Y-%m-%dT%H:%M:%S", tz = "UTC"),
           ss_updated = examples$last_updated,
           same = ws_updated == ss_updated)

## totalResults = number of worksheets
content %>% list.mapv(totalResults)
content %>%
  list.map(list.match(., "entry")) %>%
  list.map(length(.))

## useless to me, I think
content %>% list.map(category) %>% list.rbind
content %>% list.mapv(startIndex)
```

  * The `author`, and `title` components contain same information as we get from the spreadsheets feed (up to capitalization?!).
  * Apparently `updated` in the worksheets feed is not necessarily the same as the date-time reported in the spreadsheets feed. Odd.
  * `totalResults` appears to be the number of `entry` elements, which is the number of worksheets or tabs. `startIndex` remains a useless mystery.
  * `category` remains useless to me.

#### Links in the worksheets feed

```{r eval = FALSE}
jfun <- function(x) { # lots o' gymnastics required here
  links <- x %>%
    list.match("^link$") %>%
    unname %>% 
    list.rbind %>%
    as.data.frame
  links$source <- "content/link"
  links <- links %>%
    rbind(data.frame(rel = NA, type = NA, href = x$id,
                     source = "content/entry/id"))
  links %>%
    mutate(sheet_title = x[["title"]][["text"]],
           feed = "ss") %>%
    select(feed, sheet_title, source, href, rel, type)
}
ss_links <- sheet_list %>%
  list.map(jfun(.))
links <- ss_links %>%
  bind_rows
links

content_links <- content %>%
  list.map(list.match(., "link")) %>%
  list.map(list.rbind(.)) %>%
  list.map(as.data.frame(., stringsAsFactors = FALSE))
content_links[[1]] %>% str1
content_links %>% ldply
## i am here ... revise the below now that it's a tabulation task within a data.frame
all_link_names <- Reduce(union, lapply(content_links, names))
sapply(content_links,
       function(x) table(factor(names(x), levels = all_link_names)))
```

So we always have links named "alternate", "self", and "http://schemas.google.com/g/2005#feed". But there is no link named "http://schemas.google.com/g/2005#post" for the old sheet for which we only have read access.

```{r eval = FALSE}
identical(content_links %>% lapluck("self"), examples$ws_feed)
identical(req_list %>% lapluck("url"), examples$ws_feed)
```

The "self" link in the worksheets feed gives the URL of the sheet's worksheets feed (the link labelled as "http://schemas.google.com/spreadsheets/2006#worksheetsfeed" in the spreadsheets feed), which is also the `url` component of the worksheets feed. Confused yet?

```{r eval = FALSE}
content_links %>% lapluck("alternate")
examples$alternate
content_links %>% lapluck("alternate") == examples$alternate
```

It gets worse! The "alternate" link in the worksheets feed is the same as the "alternate" link in the spreadsheet feed __for new sheets_. For old sheets, these two links have the same structure but the sheet key differs. The "alternate" link from the spreadsheets feed contains what I call the *alternate key*, which is needed for the Google Drive API, whereas the "alternate" link from the worksheets feed uses what I just call the sheet's key. Which is what we use when talking to the Sheets API.

I have run out of energy for this. I can find no references in the package's current code to the worksheet feed links labelled as "http://schemas.google.com/g/2005#feed" and "http://schemas.google.com/g/2005#post", so I'm not going to delve into them.

### Structure and content of worksheets feed links

```sh
the "worksheets feed" can be found in ...
url in worksheets feed =
  id inside the *content* of the worksheets feed =
  link named "self" inside the *content* of the worksheets feed =
  link named "http://schemas.google.com/spreadsheets/2006#worksheetsfeed" inside the corresponding entry inside the content of the spreadsheets feed

https://spreadsheets.google.com/feeds/worksheets/KEY/VISIBILITY/PERMISSION
VISIBILITY = {private (default), public}
PERMISSION = {full (read and write), values (read only)}

the "alternate" link can be found in ...
  link named "alternate" in the corresponding entry inside the content of the spreadsheets feed
  link named "alternate" inside the content of the worksheets feed

for new sheets, the "alternate" link looks like this in both places:
https://docs.google.com/spreadsheets/d/KEY/edit

for old sheets, the "alternate" link looks like this:
https://spreadsheets.google.com/ccc?key=SOME_SORT_OF_KEY
where SOME_SORT_OF_KEY = ALT_KEY in the spreadsheets feed and
      SOME_SORT_OF_KEY = KEY in the worksheets feed
```

#### Entries in the worksheets feed

The `entry` components correspond to worksheets within the sheet. As we did with content and link, we make a list with one component per spreadsheet, each containing another list of the sheet's `entry` elements.

```{r eval = FALSE}
content_entries <- llply(content, lfilt, "^entry$")
content_entries %>% str1
first_ws <- content_entries %>% lapply(`[[`, 1)
all_ws_names <- Reduce(union, lapply(first_ws, names))
sapply(first_ws,
       function(x) table(factor(names(x), levels = all_ws_names)))
```

The links are our main interest. But first let's look at the titles.

```{r eval = FALSE}
content_entries %>% lapply(lapluck, "title") %>%
  lapply(function(x) unlist(x)) %>% lapply(function(x) x[seq_len(length(x)/2)])
foo <- content_entries %>% lapply(lfilt, "link")
ldply(foo, function(x) as.data.frame(x[ , c(1, 3)]))
```

Let me try to get the links now

```{r eval = FALSE}
jfun <- function(x) lfilt(x, "link")
content_entries %>% lapply(jfun)

```

```{r eval = FALSE}
req <- gsheets_GET(ws_feed)
req_list <- lapply(examples$ws_feed, gsheets_GET)

```

Let's verify that the `url` reported in worksheets feed is, in fact, the worksheets feed link from the spreadsheets feed.

* With much abuse of notation, we see that `<worksheets_feed>/content/id` is the same as `<worksheets_feed>/url` is the same as `<spreadsheets_feed>/content/ws_feed`.


```{r eval = FALSE}
ssf <- links %>%
  filter(sheet_title %in% example_sheets,
         rel %>% str_detect("2006#worksheetsfeed")) %>%
  select(sheet_title, href)
wsf <- req_list %>% list.mapv(url)
wsf <- data_frame(sheet_title = names(wsf),
                  href = wsf)
full_join(ssf, wsf, by = "sheet_title") %>%
  with(., identical(href.x, href.y))
```